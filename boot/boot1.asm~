bits	16						; we are in 16 bit real mode
org	0						; we will set regisers later
start:	jmp	main					; jump to start of bootloader

;	BIOS Parameter Block

bpbOEM			db "My OS   "			; OEM identifier (Cannot exceed 8 bytes!)
bpbBytesPerSector  	dw 512
bpbSectorsPerCluster 	db 1
bpbReservedSectors 	dw 1
bpbNumberOfFATs 	db 2
bpbRootEntries	 	dw 224
bpbTotalSectors 	dw 2880
bpbMedia 		db 0xf8  ;; 0xF1
bpbSectorsPerFAT 	dw 9
bpbSectorsPerTrack 	dw 18
bpbNumOfHeads		dw 2
bpbHiddenSectors 	dd 0
bpbTotalSectorsBig	dd 0
bpbDriveNumber		db 0
bsUnused 		db 0
bsExtBootSignature 	db 0x29
bsSerialNumber	        dd 0xa0a1a2a3
bsVolumeLabel 	        db "myOS_UZI   "
bsFileSystem 	        db "FAT12   "


print:
	lodsb				; load next byte from string from SI to AL
	or	al, al			; Does AL=0?
	jz	printDone		; Yep, null terminator found-bail out
	mov	ah, 0eh			; Nope-Print the character
	int	10h
	jmp	print			; Repeat until null terminator found
printDone:
	ret				; we are done, so return


readSectors:
	.mainLoop:
		mov	di, 0x0005                          ; five retries for error
		.sectorLoop:
			push ax
			push bx
			push cx
			call LBAtoCHS                              ; convert starting sector to CHS
			mov  ah,0x02                            ; BIOS read sector
			mov  al,0x01                            ; read one sector
			mov  ch,BYTE [absoluteTrack]            ; track
			mov  cl,BYTE [absoluteSector]           ; sector
			mov  dh,BYTE [absoluteHead]             ; head
			mov  dl,BYTE [bpbDriveNumber]            ; drive
			int  0x13                                ; invoke BIOS
			jnc  .success                            ; test for read error
			xor  ax,ax                              ; BIOS reset disk
			int  0x13                                ; invoke BIOS
			dec  di                                  ; decrement error counter
			pop  cx
			pop  bx
			pop  ax
			jnz  .sectorLoop                         ; attempt to read again
			int  0x18
		.success:
			mov  si,msgProgress
			call print
			pop  cx
			pop  bx
			pop  ax
			add  bx,WORD[bpbBytesPerSector]		; queue next buffer
			inc  ax					; queue next sector
			loop .mainLoop				; read next sector
ret

clusterLBA:
	sub ax,0x0002                          ; zero base cluster number
	xor cx,cx
	mov cl,BYTE [bpbSectorsPerCluster]     ; convert byte to word
	mul cx
	add ax,WORD [dataSector]               ; base data sector
ret

LBAtoCHS:
	xor dx,dx                              ; prepare dx:ax for operation
	div WORD[bpbSectorsPerTrack]           ; calculate
	inc dl                                  ; adjust for sector 0
	mov BYTE[absoluteSector],dl
	xor dx,dx                              ; prepare dx:ax for operation
	div WORD[bpbNumOfHeads]			; calculate
	mov BYTE[absoluteHead],dl
	mov BYTE[absoluteTrack],al
ret

;LBAtoCHS:
;	xor dx,dx
;	mov ax,[baseAddress]
;	div BYTE[bpbSectorsPerTrack]
;	mov BYTE[absoluteTrack],al
;
;	inc dx
;	mov BYTE[absoluteSector],dl
;	xor ax,ax
;	xor dx,dx
;	mov al,BYTE[absoluteTrack]
;	div BYTE[bpbNumOfHeads]
;	mov BYTE[absoluteHead],dl
;ret

;Bootloader Entry Point

main:

	; code located at 0000:7C00, adjust segment register
	cli					; disable interrupts
	mov ax, 0x07C0				; setup registers to point to our segment
	mov ds, ax
	mov es, ax
	mov fs, ax
	mov gs, ax

	; create stack

	mov ax, 0x0000				; set the stack
	mov ss, ax
	mov sp, 0xFFFF
	sti						; restore interrupts

	; Display loading message     
	mov si, msgLoading
	call print

	; Load root directory table

	loadRoot:

		; compute size of root directory and store in "cx"
		xor cx,cx
		xor dx,dx
		mov ax,0x0020                           ; 32 byte directory entry
		mul WORD[bpbRootEntries]                ; total size of directory
		div WORD[bpbBytesPerSector]             ; sectors used by directory
		xchg ax,cx

		; compute location of root directory and store in "ax"
     
		mov     al,BYTE[bpbNumberOfFATs]            ; number of FATs
		mul     WORD[bpbSectorsPerFAT]               ; sectors used by FATs
		add     ax,WORD[bpbReservedSectors]         ; adjust for bootsector
		mov     WORD[dataSector],ax                 ; base of root directory
		add     WORD[dataSector],cx

		; read root directory into memory (7C00:0200)
		mov  bx, 0x0200                            ; copy root dir above bootcode
		call readSectors
;mov si, msgDebug
;call print

	; Find stage 2

	; browse root directory for binary image
	mov cx, WORD [bpbRootEntries]             ; load loop counter
	mov di, 0x0200                            ; locate first root entry
	.loopHere:
		push cx
		mov  cx,0x000B                            ; eleven character name
		mov  si,ImageName                         ; image name to find
		push di
		rep  cmpsb                                         ; test for entry match
		pop  di
		je   loadFat
		pop  cx
		add  di,0x0020                            ; queue next directory entry
		loop .loopHere
		jmp  failure

	;load FAT
	loadFat:
		; save starting cluster of boot image
		mov  si,msgCRLF
		call print
		mov  dx,WORD[di+0x001A]
		mov  WORD[cluster],dx                  ; file's first cluster

		; compute size of FAT and store in "cx"
		xor  ax,ax
		mov  al,BYTE[bpbNumberOfFATs]          ; number of FATs
		mul  WORD[bpbSectorsPerFAT]             ; sectors used by FATs
		mov  cx,ax

		; compute location of FAT and store in "ax"
		mov  ax,WORD[bpbReservedSectors]       ; adjust for bootsector
		; read FAT into memory (7C00:0200)
		mov  bx,0x0200                          ; copy FAT above bootcode
		call readSectors
		; read image file into memory (0050:0000)
		mov  si,msgCRLF
		call print
		mov  ax,0x0000
		mov  es,ax                              ; destination for image
		mov  bx,0x0200                          ; destination for image
		push bx

	; Load Stage 2

	loadImage:
		mov  ax,WORD[cluster]                    ; cluster to read
		pop  bx                                  ; buffer to read into
		call clusterLBA                          ; convert cluster to LBA
		xor  cx,cx
		mov  cl,BYTE[bpbSectorsPerCluster]     ; sectors to read
		call readSectors
		push bx
          
	; compute next cluster
	mov     ax,WORD[cluster]                  ; identify current cluster
	mov     cx,ax                              ; copy current cluster
	mov     dx,ax                              ; copy current cluster
	shr     dx,0x0001                          ; divide by two
	add     cx,dx                              ; sum for (3/2)
	mov     bx,0x0200                          ; location of FAT in memory
	add     bx,cx                              ; index into FAT
	mov     dx,WORD[bx]                       ; read two bytes from FAT
	test    ax,0x0001
	jnz     .oddCluster

	.evenCluster:
		and     dx,0000111111111111b               ; take low twelve bits
		jmp     .doneEvenCluster

	.oddCluster:
		shr     dx,0x0004                          ; take high twelve bits

	.DONE:
		mov WORD[cluster],dx                  ; store new cluster
		cmp dx,0x0FF0                          ; test for end of file
		jb  loadImage

	.doneEvenCluster:
		mov  si,msgCRLF
		call print
		push WORD 0x0050
		push WORD 0x0000
	retf

failure:
	mov     si, msgFailure
	call    print
	mov     ah, 0x00
	int     0x16                                ; await keypress
	int     0x19                                ; warm boot computer

absoluteSector	db	0x00
absoluteHead	db	0x00
absoluteTrack	db	0x00

dataSector	dw	0x0000
cluster		dw	0x0000

ImageName	db	"BOOT2   SYS"	; 11 bits

msgDebug	db	0x0D, 0x0A, "Debug:",0x00
msgLoading	db	0x0D, 0x0A, "Booting in progress", 0x0D, 0x0A, 0x00
msgCRLF		db	0x0D, 0x0A, 0x00
msgProgress	db	".", 0x00
msgFailure	db	0x0D, 0x0A, "Error: Press Reboot", 0x0A, 0x00
     
TIMES 510-($-$$) DB 0
DW 0xAA55
