%ifndef __STDIO_INC_063244045_INCLUDED__
%define __STDIO_INC_063244045_INCLUDED__

bits 16

;--------------------------------------------------------------------------------------
print:
	lodsb				; load next byte from string from SI to AL
	or	al, al			; Does AL=0?
	jz	printDone		; Yep, null terminator found-bail out
	mov	ah, 0eh			; Nope-Print the character
	int	10h
	jmp	print			; Repeat until null terminator found
printDone:
	ret				; we are done, so return
;--------------------------------------------------------------------------------------
printAX:
	push cx
	mov cx, 4
next_digit:
	push cx
	mov cl, 4
	rol ax, cl
	push ax
	and al, 0x0f
	add al, '0'
	cmp al, '9'
	jle not_a_letter
	add al, 'A'-'9'-1
not_a_letter:
  ; Now write the character AL to the screen
  	mov ah, 0x0e ; teletype sub-function.
	int 0x10
	pop ax
	pop cx
	loop next_digit
	pop cx
ret
;--------------------------------------------------------------------------------------

;-----------------------------------------------------------------
;INT 0x13/AH=0x02 - DISK : READ SECTOR(S) INTO MEMORY
;AH = 0x02
;AL = Number of sectors to read
;CH = Low eight bits of cylinder number
;CL = Sector Number (Bits 0-5). Bits 6-7 are for hard disks only
;DH = Head Number
;DL = Drive Number (Bit 7 set for hard disks)
;ES:BX = Buffer to read sectors to
;===================================
;Returns:
;AH = Status Code
;AL = Number of sectors read
;CF = set if failure, cleared is successfull
; readSectors(@es:bx, @ax): 
;-----------------------------------------------------------------
readSectors:
	.mainLoop:
		mov	di, 0x0005                          ; five retries for error
		.sectorLoop:
			push ax
			push bx
			push cx
			call LBAtoCHS                              ; convert starting sector to CHS
			mov  ah,0x02                            ; BIOS read sector
			mov  al,0x01                            ; read one sector
			mov  ch,BYTE [absoluteTrack]            ; track
			mov  cl,BYTE [absoluteSector]           ; sector
			mov  dh,BYTE [absoluteHead]             ; head
			mov  dl,BYTE [bpbDriveNumber]            ; drive
			int  0x13                                ; invoke BIOS
			jnc  .success                            ; test for read error
			xor  ax,ax                              ; BIOS reset disk
			int  0x13                                ; invoke BIOS
			dec  di                                  ; decrement error counter
			pop  cx
			pop  bx
			pop  ax
			jnz  .sectorLoop                         ; attempt to read again
			int  0x18
		.success:
			mov  si,msgProgress
			call print
			pop  cx
			pop  bx
			pop  ax
			add  bx, WORD[bpbBytesPerSector]		; queue next buffer
			inc  ax					; queue next sector
			loop .mainLoop				; read next sector
ret
;-------------------------------------------------------------------------
; sector is 512 bytes.
; Track is a circle can be divided into sectors.
; Cylinder is group of tracks withb fixed radius.
; Two heads for each track.
; es:bx is buffer
; clusterLBA(@ax): return ax
;-------------------------------------------------------------------------
clusterLBA:
	; input ax= cluster
	; lba= (cluster-2)*sectorsPerCluster
	sub ax,0x0002                          ; zero base cluster number
	xor cx,cx
	mov cl,BYTE [bpbSectorsPerCluster]     ; convert byte to word
	mul cx
	add ax,WORD [dataSector]               ; base data sector
ret
;-----------------------------------------------------------------
; Note:
; div: divides ax by operand. outputs ax=quotient, dx=remainder.
; module(%): gives the remainder.
; mul: multiplies ax by operand. Output is ax:cx.
;-----------------------------------------------------------------
LBAtoCHS:
	; input param: ax= lba value = calculated cluster location
	;-------------------------------------------
	; output:
	; absoluteSector=(lba%sectorPerTrack)+(1)
	; absoluteTrack/cylinder=(lba/sectorPerTrack)/(numOfHeads)
	; absoluteHead=(lba/sectorPerTrack)%(numOfHeads)
	;------------------------------------------- 
	;=================================================================
 	  xor	dx, dx                              ; prepare dx:ax for operation
          div	WORD [bpbSectorsPerTrack]           ; calculate
          inc	dl                                  ; adjust for sector 0
          ; sector:
		mov     BYTE [absoluteSector], dl
	  ;---------------------------------
	  xor	dx, dx                              ; prepare dx:ax for operation
	  div	WORD [bpbNumOfHeads]          	    ; calculate
	  ; cylinder:
		mov     BYTE [absoluteTrack], al
	  ;---------------------------------
          ; head:
	  	mov	BYTE [absoluteHead], dl
	  ;---------------------------------
	;=================================================================	
ret
;----------------------------------------------------------------------------------------------
%endif
